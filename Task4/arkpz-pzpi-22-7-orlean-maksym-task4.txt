Міністерство освіти і науки України Харківський національний університет радіоелектроніки


Кафедра програмної інженерії








Звіт
З лабораторної роботи №4
З дисципліни «Аналіз та рефакторинг коду» на тему: «РОЗРОБКА IoT КЛІЄНТА»















Виконав
ст. гр. ПЗПІ-22-7
Орлеан М.Е.	Перевірив ст.
викладач каф. ПІ Сокорчук І. П.









Харків 2024
 
1 МЕТА РОБОТИ

Розробити клієнт IoT, який здійснює збір, аналіз і передачу даних на сервер відповідно до принципів Інтернету речей. Реалізувати бізнес-логіку, функціонал налаштування пристрою та забезпечити інтеграцію з іншими компонентами системи.

2 ХІД РОБОТИ

Враховуючи специфіку вашого проекту, де ви збираєте дані з різних датчиків (температури, вологості, освітленості, прискорення), ось як можна адаптувати та переписати хід роботи для вашого коду:
Хід роботи проекту:
1.	Ініціалізація датчиків:
•	DHT22: Цей датчик використовується для вимірювання температури та вологості. Він підключений до піну 14 (DHTPIN). Після ініціалізації в методі setup(), ми зчитуємо значення температури та вологості кожні 2 секунди.
•	Фоторезистор (LDR): Цей датчик використовується для вимірювання рівня освітленості навколишнього середовища. Підключений до аналогового піну 34 (LDR_PIN).
•	Акселерометр: Вимірює прискорення в трьох осях (X, Y, Z). В цьому коді ми емулюємо зчитування цих значень через аналогові піні (32, 33, 34 для осей X, Y, Z).
2.	Підключення до Wi-Fi:
•	Ми підключаємо ESP32 до вашої Wi-Fi мережі, використовуючи бібліотеку WiFi.h. При успішному підключенні, в серійному моніторі з'явиться повідомлення "Підключено до Wi-Fi".
3.	MQTT протокол:
•	Використовуємо бібліотеку PubSubClient для підключення до MQTT брокера (у цьому випадку broker.hivemq.com). Дані з датчиків передаються через MQTT в різні топіки: 
•	Температура відправляється в топік iot/data/temperature
•	Вологість у топік iot/data/humidity
•	Рівень освітленості у топік iot/data/ldr
•	Дані про прискорення (осі X, Y, Z) відправляються в топік iot/data/acceleration
4.	Відправка даних:
•	Після зчитування значень кожного датчика, ці дані публікуються в MQTT топіки. Якщо дані успішно відправлено, виводиться відповідне повідомлення в серійному моніторі.
5.	Перевірка підключення до MQTT:
•	Кожен цикл програми перевіряє, чи підключений пристрій до MQTT брокера. Якщо підключення втрачено, автоматично відбувається спроба повторного підключення.
6.	Інтервал зчитування даних:
•	Дані зчитуються кожні 2 секунди (функція delay(2000)).
Кроки роботи з кодом:
1.	Ініціалізація бібліотек:
1. Підключення необхідних бібліотек для роботи з датчиками та MQTT: 
1. #include <Wire.h>
2. #include <Adafruit_Sensor.h>
3. #include <DHT_U.h>
4. #include <DHT.h>
5. #include <WiFi.h>
6. #include <PubSubClient.h>
2.	Налаштування пінів та датчиків:
Визначаємо піні для кожного датчика: 
1. #define DHTPIN 14    // Пін для датчика DHT22
2. #define LDR_PIN 34  // Пін для фоторезистора (аналоговий)
3. #define ACCEL_X_PIN 32  // Пін для акселерометра X
4. #define ACCEL_Y_PIN 33  // Пін для акселерометра Y
5. #define ACCEL_Z_PIN 34  // Пін для акселерометра Z
3.	Підключення до Wi-Fi:
Підключення до Wi-Fi мережі для отримання доступу до інтернету та можливості підключення до MQTT брокера.
4.	MQTT:
З'єднуємося з MQTT брокером і підключаємося до топіків для публікації даних: 
1. const char* mqtt_server = "broker.hivemq.com";
5.	Зчитування даних:
1. //Датчики температури та вологості: 
2. dht.temperature().getEvent(&event);
3. dht.humidity().getEvent(&event);
4. //Дані з фоторезистора та акселерометра: 
5. int ldrValue = analogRead(LDR_PIN);
6. int accelX = analogRead(ACCEL_X_PIN);
7. int accelY = analogRead(ACCEL_Y_PIN);
8. int accelZ = analogRead(ACCEL_Z_PIN);
6.	Відправка даних через MQTT:
Дані відправляються в топіки MQTT: 
1. client.publish("iot/data/temperature", temp.c_str());
2. client.publish("iot/data/humidity", humidity.c_str());
3. client.publish("iot/data/ldr", ldr.c_str());
4. client.publish("iot/data/acceleration", accelData.c_str());
7.	Затримка:
Чекаємо 2 секунди перед наступним зчитуванням: 
1. delay(2000);
________________________________________
Цей підхід дозволяє зібрати та передати дані з кількох датчиків (температура, вологість, освітленість, прискорення) через MQTT, що робить систему готовою до використання в реальних IoT додатках для моніторингу та управління різноманітними датчиками в транспорті, для аналізу стану навколишнього середовища та інших цілей.
 
 
Рисунок 2.1 – Схема IoT пристрою


2.1	Фрагменти програмного коду

2.1.1	Бізнес-логіка IoT-клієнта


Фрагмент коду зчитування даних сенсорів: Код наведено у додатку А.

2.1.2	Налаштування IoT-клієнта

Фрагмент коду підключення до Wi-Fi:
1  void setup() {
2    Serial.begin(115200);
3    WiFi.begin(ssid, password);
4    
5    while (WiFi.status() != WL_CONNECTED) {
6      Serial.println("Connecting to WiFi...");
7    }
8    Serial.println("Connected to WiFi");
9    client.setServer(mqtt_server, mqtt_port);
10    sensors.begin();
11  }

2.2	UML Діаграми


2.2.1	Діаграма прецедентів IoT клієнта

 
Рисунок 2.3.1 – UML діаграма прецедентів IoT клієнта

Діаграма прецедентів описує взаємодію IoT-клієнта з користувачем, Wi-Fi, MQTT-брокером, датчиком температури та акселерометром. Основні прецеденти включають підключення до Wi-Fi, збір даних із сенсорів та відправлення даних на MQTT-брокер.

2.2.2	Діаграма діяльності IoT клієнта


Діаграма діяльності показує весь процес роботи IoT-клієнта, починаючи з ініціалізації системи та підключення до Wi-Fi мережі. У разі успішного з’єднання клієнт активує сенсори для збору даних, таких як температура та показники акселерометра.
 Після отримання даних від сенсорів система обробляє їх і готує до відправки. Потім IoT-клієнт намагається передати ці дані на MQTT-брокер. Якщо передача проходить успішно, з’являється повідомлення про успіх. Якщо ж передача не вдається, система повторює спробу відправки до досягнення позитивного результату.

 
Рисунок 2.3.2– UML діаграма діяльності IoT клієнта


3 ВИСНОВКИ

У процесі виконання лабораторної роботи був успішно розроблений IoT-клієнт для моніторингу стану пристроїв на основі датчиків, що відповідає сучасним вимогам до розумних пристроїв та IoT-систем. Реалізовано ефективний збір, обробку та передачу даних з сенсорів для вимірювання температури, вологості, освітленості та даних з акселерометра. Завдяки налаштуванню клієнта на передачу даних через MQTT, забезпечено можливість інтеграції цього пристрою в більші системи для віддаленого моніторингу стану. Це підкреслює практичну цінність розробленого IoT-клієнта для використання в системах моніторингу та автоматизації.

 
 
Додаток А


1.  #include <Wire.h>
2.  #include <Adafruit_Sensor.h>
3.  #include <DHT_U.h>
4.  #include <DHT.h>
5.  #include <WiFi.h>
6.  #include <PubSubClient.h>
7.  // Ініціалізація пінів та датчиків
8.  #define SDA_PIN 21  // Пін SDA
9.  #define SCL_PIN 22  // Пін SCL
10. #define DHTPIN 14    // Пін для датчика DHT22
11. #define DHTTYPE DHT22
12. DHT_Unified dht(DHTPIN, DHTTYPE);
13. #define LDR_PIN 34  // Пін для фоторезистора (аналоговий)
14. #define ACCEL_X_PIN 32  // Пін для акселерометра X
15. #define ACCEL_Y_PIN 33  // Пін для акселерометра Y
16. #define ACCEL_Z_PIN 34  // Пін для акселерометра Z
17. // Параметри MQTT
18. const char* ssid = "Wokwi-GUEST"; // Ваше ім'я Wi-Fi мережі
19. const char* password = ""; // Ваш пароль Wi-Fi
20. const char* mqtt_server = "broker.hivemq.com"; // Адреса MQTT брокера
21. WiFiClient espClient;
22. PubSubClient client(espClient);
23. // Функція для підключення до Wi-Fi
24. void setup_wifi() {
25.   Serial.print("Підключення до Wi-Fi...");
26.   WiFi.begin(ssid, password);
27.   while (WiFi.status() != WL_CONNECTED) {
28.     delay(1000);
29.     Serial.print(".");
30.   }
31.   Serial.println("Підключено до Wi-Fi");
32. }
33. // Функція для підключення до MQTT брокера
34. void reconnect() {
35.   while (!client.connected()) {
36.     Serial.print("Підключення до MQTT...");
37.     if (client.connect("ESP32Client")) {
38.       Serial.println("Підключено");
39.     } else {
40.       Serial.print("Помилка, спробую знову через 5 секунд");
41.       delay(5000);
42.     }
43.   }
44. }
45. void setup() {
46.   Serial.begin(115200);
47.   setup_wifi();
48.   client.setServer(mqtt_server, 1883); // Підключення до брокера через порт 1883
49.   dht.begin();
50. }
51. void loop() {
52.   // Підключення до MQTT
53.   if (!client.connected()) {
54.     reconnect();
55.   }
56.   client.loop();
57.   // Читання температури та вологості з датчика DHT22
58.   sensors_event_t event;
59.   dht.temperature().getEvent(&event);
60.   if (!isnan(event.temperature)) {
61.     String temp = String(event.temperature);
62.     if (client.publish("iot/data/temperature", temp.c_str())) {
63.       Serial.println("Дані температури успішно відправлено!");
64.     }
65.   }
66.   dht.humidity().getEvent(&event);
67.   if (!isnan(event.relative_humidity)) {
68.     String humidity = String(event.relative_humidity);
69.     if (client.publish("iot/data/humidity", humidity.c_str())) {
70.       Serial.println("Дані про вологість успішно відправлено!");
71.     }
72.   }
73.   // Читання значення з фоторезистора (LDR)
74.   int ldrValue = analogRead(LDR_PIN);
75.   String ldr = String(ldrValue);
76.   if (client.publish("iot/data/ldr", ldr.c_str())) {
77.     Serial.println("Дані про освітленість успішно відправлено!");
78.   }
79.   // Читання даних з акселерометра (імітація через аналогові піні)
80.   int accelX = analogRead(ACCEL_X_PIN);
81.   int accelY = analogRead(ACCEL_Y_PIN);
82.   int accelZ = analogRead(ACCEL_Z_PIN);
83.   String accelData = "X: " + String(accelX) + ", Y: " + String(accelY) + ", Z: " + String(accelZ);
84.   if (client.publish("iot/data/acceleration", accelData.c_str())) {
85.     Serial.println("Дані про прискорення успішно відправлено!");
86.   }
87.   delay(2000);  // Затримка перед наступним зчитуванням
88. }
